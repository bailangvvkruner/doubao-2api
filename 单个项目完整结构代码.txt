é¡¹ç›® 'doubao-2api' çš„ç»“æ„æ ‘:
ğŸ“‚ doubao-2api/
    ğŸ“„ .env
    ğŸ“„ .env.example
    ğŸ“„ Dockerfile
    ğŸ“„ docker-compose.yml
    ğŸ“„ main.py
    ğŸ“„ nginx.conf
    ğŸ“„ requirements.txt
    ğŸ“‚ app/
        ğŸ“‚ core/
            ğŸ“„ __init__.py
            ğŸ“„ config.py
        ğŸ“‚ providers/
            ğŸ“„ __init__.py
            ğŸ“„ base_provider.py
            ğŸ“„ doubao_provider.py
        ğŸ“‚ services/
            ğŸ“„ credential_manager.py
            ğŸ“„ playwright_manager.py
            ğŸ“„ session_manager.py
        ğŸ“‚ utils/
            ğŸ“„ sse_utils.py
================================================================================

--- æ–‡ä»¶è·¯å¾„: .env ---

# [è‡ªåŠ¨å¡«å……] doubao-2api ç”Ÿäº§ç¯å¢ƒé…ç½®
# è¯¥æ–‡ä»¶ç”± Project Chimera: Synthesis Edition è‡ªåŠ¨ç”Ÿæˆã€‚

# --- æ ¸å¿ƒå®‰å…¨é…ç½® ---
# ç”¨äºä¿æŠ¤æ‚¨çš„ API æœåŠ¡çš„è®¿é—®å¯†é’¥ã€‚ä¸ºå®‰å…¨èµ·è§ï¼Œå»ºè®®ä¿®æ”¹ä¸ºæ‚¨è‡ªå·±çš„å¤æ‚å¯†é’¥ã€‚
API_MASTER_KEY=1

# --- éƒ¨ç½²é…ç½® ---
# Nginx å¯¹å¤–æš´éœ²çš„ç«¯å£
NGINX_PORT=8088

# --- è±†åŒ…å‡­è¯ (æ”¯æŒå¤šè´¦å·) ---
# å·²ä»æ‚¨æä¾›çš„æŠ“åŒ…æ•°æ®ä¸­è‡ªåŠ¨æå–ã€‚
# æ‚¨å¯ä»¥æ·»åŠ  DOUBAO_COOKIE_2, DOUBAO_COOKIE_3 ç­‰æ¥å¯ç”¨å¤šè´¦å·è½®è¯¢ã€‚
# å…³é”®ä¿®å¤ï¼šå°†æ‰€æœ‰ $ æ›¿æ¢ä¸º $$ ä»¥é˜²æ­¢ docker-compose é”™è¯¯åœ°è¿›è¡Œå˜é‡æ›¿æ¢
DOUBAO_COOKIE_1="_ga=GA1.1.106161677.1751986993; flow_user_country=CN; gd_random=eyJtYXRjaCI6dHJ1ZSwicGVyY2VudCI6MC40MDU4OTQxMTgwNjU5MTE5fQ==.uh5yd/EnUakcjRfWWa6OAVFeFHG5u3323TQ8c+A+MLk=; i18next=zh; flow_ssr_sidebar_expand=1; s_v_web_id=verify_mgyqvccs_blJSa2yy_7EW7_4Hyr_Ato6_bIPsXGNXitoz; passport_csrf_token=9eb3d0afec2be115cdb721e991cad1b3; passport_csrf_token_default=9eb3d0afec2be115cdb721e991cad1b3; passport_mfa_token=CjH5jul%2F30qQ%2BaY1jB%2Bnx8LpCcE48Hfop4c3MhxuEeBUFGs%2F8N4JhuZF4s7GeMeZN4w7GkoKPAAAAAAAAAAAAABPnWDhWnZOf2mKtl3lVJ%2FVMkKzWl5s%2BC8ctO%2BrbX8YwHlINTsmlfrNIskE71bYKnJQZRCEqf8NGPax0WwgAiIBA94Lbu8%3D; d_ticket=36e308ea7e3ffb14723f2139e51a83650034a; odin_tt=2eaa81b7b48fba60218c5f378553f4ce3c982fb25d8ee50efd4068f0427b0d95acf5f4570a1dc7c49aca53a61ed61ffb61c9e3f6c3eed5aa61fdb4ad6e00367f; n_mh=-FPXT10Y1ouY2RTXstCfFAbnlgz1v6FIer_PG9SzZ44; passport_auth_status=ba23b06ba9b3eb71cad40d03cc59fee6%2C; passport_auth_status_ss=ba23b06ba9b3eb71cad40d03cc59fee6%2C; sid_guard=3aa7bb87c6eeb0906760f16063aed75e%7C1760941125%7C2592000%7CWed%2C+19-Nov-2025+06%3A18%3A45+GMT; uid_tt=111f0e12e200a498139cb9e298827580; uid_tt_ss=111f0e12e200a498139cb9e298827580; sid_tt=3aa7bb87c6eeb0906760f16063aed75e; sessionid=3aa7bb87c6eeb0906760f16063aed75e; sessionid_ss=3aa7bb87c6eeb0906760f16063aed75e; session_tlb_tag=sttt%7C12%7COqe7h8busJBnYPFgY67XXv__________uXbtksAL_RkZw0L15F060kJ4FWWF3mfsmREcj6H4lXQ%3D; is_staff_user=false; sid_ucp_v1=1.0.0-KGI3YjM1OTk4NzUzOTM2MTY1Yjc4ZWM2M2Y0MDM3NmYwZTZhYzdjMzQKIAj5tLDq9a3wARDFqNfHBhjCsR4gDDDFqNfHBjgCQOwHGgJsZiIgM2FhN2JiODdjNmVlYjA5MDY3NjBmMTYwNjNhZWQ3NWU; ssid_ucp_v1=1.0.0-KGI3YjM1OTk4NzUzOTM2MTY1Yjc4ZWM2M2Y0MDM3NmYwZTZhYzdjMzQKIAj5tLDq9a3wARDFqNfHBhjCsR4gDDDFqNfHBjgCQOwHGgJsZiIgM2FhN2JiODdjNmVlYjA5MDY3NjBmMTYwNjNhZWQ3NWU; ttwid=1%7CYEzH0bhSHZjjqJLjeG5eHfpnB2RWiIe7DuumYAzUrDM%7C1760941158%7Cb7af9ac18f1a4364c95082df532abdbe68c1cb101f0af864be1eed84eff356a2; passport_fe_beating_status=true; _ga_G8EP5CG8VZ=GS2.1.s1760941083$$o54$$g1$$t1760941158$$j60$$l0$$h0"

# --- æ ¸å¿ƒå˜æ›´: é™æ€è®¾å¤‡æŒ‡çº¹ ---
# ä»æµè§ˆå™¨æŠ“åŒ…çš„æœ‰æ•ˆè¯·æ±‚ä¸­æå–ï¼Œä»¥æ›¿æ¢ä¸ç¨³å®šã€æ˜“å¤±æ•ˆçš„åŠ¨æ€å—…æ¢ã€‚
# å¦‚æœæœªæ¥æœåŠ¡å¤±æ•ˆï¼Œå¤§æ¦‚ç‡æ˜¯è¿™äº›å€¼è¿‡æœŸäº†ï¼Œå±Šæ—¶è¯·é‡æ–°æŠ“åŒ…å¹¶æ›´æ–°ã€‚
DOUBAO_DEVICE_ID=7524726744148264511
DOUBAO_FP=verify_mgyqvccs_blJSa2yy_7EW7_4Hyr_Ato6_bIPsXGNXitoz
DOUBAO_TEA_UUID=7524726753203160619
DOUBAO_WEB_ID=7524726753203160619

# --- ä¼šè¯ç®¡ç† (å¯é€‰) ---
# å¯¹è¯å†å²åœ¨å†…å­˜ä¸­çš„ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤1å°æ—¶
SESSION_CACHE_TTL=3600


--- æ–‡ä»¶è·¯å¾„: .env.example ---

# /.env.example
# ====================================================================
# doubao-2api é…ç½®æ–‡ä»¶æ¨¡æ¿
# ====================================================================
#
# è¯·å°†æ­¤æ–‡ä»¶é‡å‘½åä¸º ".env" å¹¶å¡«å…¥æ‚¨çš„å‡­è¯ã€‚
#

# --- æ ¸å¿ƒå®‰å…¨é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç”¨äºä¿æŠ¤æ‚¨ API æœåŠ¡çš„è®¿é—®å¯†é’¥ã€‚
API_MASTER_KEY=sk-doubao-2api-default-key-please-change-me

# --- éƒ¨ç½²é…ç½® (å¯é€‰) ---
# Nginx å¯¹å¤–æš´éœ²çš„ç«¯å£
NGINX_PORT=8088

# --- è±†åŒ…å‡­è¯ (å¿…é¡»è®¾ç½®) ---
# è¯·ä»æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä¸­è·å–å®Œæ•´çš„ Cookie å­—ç¬¦ä¸²ã€‚
# ç™»å½• https://www.doubao.com/chat/ åï¼ŒæŒ‰ F12 æ‰“å¼€å¼€å‘è€…å·¥å…·ï¼Œ
# åˆ‡æ¢åˆ°â€œç½‘ç»œ(Network)â€é¢æ¿ï¼Œéšä¾¿å‘é€ä¸€æ¡æ¶ˆæ¯ï¼Œ
# åœ¨è¯·æ±‚åˆ—è¡¨ä¸­æ‰¾åˆ° `completion` è¯·æ±‚ï¼Œå³é”® -> å¤åˆ¶ -> å¤åˆ¶ä¸º cURL (bash)ï¼Œ
# ç„¶åä» cURL å‘½ä»¤ä¸­æ‰¾åˆ° `--cookie '...'` éƒ¨åˆ†ï¼Œå°†å…¶ä¸­çš„å†…å®¹ç²˜è´´åˆ°ä¸‹æ–¹ã€‚
#
# æ”¯æŒå¤šè´¦å·è½®è¯¢ï¼Œåªéœ€æŒ‰æ ¼å¼æ·»åŠ  DOUBAO_COOKIE_2, DOUBAO_COOKIE_3, ...
DOUBAO_COOKIE_1="åœ¨æ­¤å¤„ç²˜è´´æ‚¨çš„å®Œæ•´ Cookie å­—ç¬¦ä¸²"

# --- ä¼šè¯ç®¡ç† (å¯é€‰) ---
# å¯¹è¯å†å²åœ¨å†…å­˜ä¸­çš„ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤1å°æ—¶
SESSION_CACHE_TTL=3600


--- æ–‡ä»¶è·¯å¾„: Dockerfile ---

# /Dockerfile
# ====================================================================
# Dockerfile for doubao-2api (v1.4 - Patched for User Permissions)
# ====================================================================

# ä½¿ç”¨ä¸€ä¸ªç¨³å®šã€å¹¿æ³›æ”¯æŒçš„ Debian ç‰ˆæœ¬ä½œä¸ºåŸºç¡€é•œåƒ
FROM python:3.10-slim-bookworm

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
WORKDIR /app

# å…³é”®ä¿®æ­£: ä¸€æ¬¡æ€§ã€å®Œæ•´åœ°å®‰è£…æ‰€æœ‰ç³»ç»Ÿä¾èµ–
# åˆå¹¶äº† Playwright å®˜æ–¹å»ºè®®çš„æ ¸å¿ƒåº“å’Œæˆ‘ä»¬ä¹‹å‰å‘ç°çš„å­—ä½“åº“
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Playwright æ ¸å¿ƒä¾èµ–
    libnss3 libnspr4 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 \
    libcups2 libdrm2 libxkbcommon0 libxcomposite1 libxdamage1 libxfixes3 \
    libxrandr2 libgbm1 libasound2 libatspi2.0-0 \
    # å®˜æ–¹é”™è¯¯æ—¥å¿—ä¸­æ˜ç¡®æç¤ºç¼ºå°‘çš„å…³é”®åº“
    libpango-1.0-0 libcairo2 \
    # è§£å†³å­—ä½“é—®é¢˜çš„åŒ…
    fonts-unifont fonts-liberation \
    # æ¸…ç† apt ç¼“å­˜ä»¥å‡å°é•œåƒä½“ç§¯
    && rm -rf /var/lib/apt/lists/*

# å®‰è£… Python ä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºå¹¶åˆ‡æ¢åˆ°é root ç”¨æˆ·
# è¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œæˆ‘ä»¬å…ˆåˆ›å»ºç”¨æˆ·ï¼Œç„¶åä»¥è¯¥ç”¨æˆ·èº«ä»½å®‰è£…æµè§ˆå™¨
RUN useradd --create-home appuser && \
    chown -R appuser:appuser /app
USER appuser

# æ ¸å¿ƒä¿®å¤ï¼šä»¥ appuser çš„èº«ä»½å®‰è£… Chromium æµè§ˆå™¨
# è¿™å¯ä»¥ç¡®ä¿æµè§ˆå™¨å®‰è£…åœ¨ /home/appuser/.cache/ms-playwright/ ç›®å½•ä¸‹ï¼Œ
# ä¸åº”ç”¨è¿è¡Œæ—¶æŸ¥æ‰¾çš„è·¯å¾„ä¸€è‡´ï¼Œä»è€Œè§£å†³ "Executable doesn't exist" é”™è¯¯ã€‚
RUN playwright install chromium

# æš´éœ²ç«¯å£å¹¶å¯åŠ¨
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]


--- æ–‡ä»¶è·¯å¾„: docker-compose.yml ---

# /docker-compose.yml
services:
  nginx:
    image: nginx:latest
    container_name: doubao-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8088}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - doubao-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: doubao-2api-app
    restart: unless-stopped
    env_file:
      - .env
    networks:
      - doubao-net

networks:
  doubao-net:
    driver: bridge


--- æ–‡ä»¶è·¯å¾„: main.py ---

# /main.py
import sys
import json
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse, StreamingResponse
from loguru import logger

from app.core.config import settings
from app.providers.doubao_provider import DoubaoProvider

# --- é…ç½® Loguru ---
logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
           "<level>{level: <8}</level> | "
           "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
    colorize=True
)

# --- å…¨å±€ Provider å®ä¾‹ ---
provider: Optional[DoubaoProvider] = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    global provider
    logger.info(f"åº”ç”¨å¯åŠ¨ä¸­... {settings.APP_NAME} v{settings.APP_VERSION}")
    provider = DoubaoProvider()
    await provider.initialize()
    logger.info("æœåŠ¡å·²è¿›å…¥ 'JS-Signature-as-a-Service' æ¨¡å¼ã€‚")
    logger.info(f"æœåŠ¡å°†åœ¨ http://localhost:{settings.NGINX_PORT} ä¸Šå¯ç”¨")
    yield
    await provider.close()
    logger.info("åº”ç”¨å…³é—­ã€‚")

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

# --- å®‰å…¨ä¾èµ– ---
async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="éœ€è¦ Bearer Token è®¤è¯ã€‚")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="æ— æ•ˆçš„ API Keyã€‚")

# --- API è·¯ç”± ---
@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)])
async def chat_completions(request: Request):
    try:
        request_data = await request.json()
        logger.info(f"æ”¶åˆ°å®¢æˆ·ç«¯è¯·æ±‚ /v1/chat/completions:\n{json.dumps(request_data, indent=2, ensure_ascii=False)}")
        return await provider.chat_completion(request_data)
    except Exception as e:
        logger.error(f"å¤„ç†èŠå¤©è¯·æ±‚æ—¶å‘ç”Ÿé¡¶å±‚é”™è¯¯: {e}", exc_info=True)
        if isinstance(e, HTTPException):
            raise e
        raise HTTPException(status_code=500, detail=f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}")

@app.get("/v1/models", dependencies=[Depends(verify_api_key)], response_class=JSONResponse)
async def list_models():
    return await provider.get_models()

@app.get("/", summary="æ ¹è·¯å¾„", include_in_schema=False)
def root():
    return {"message": f"æ¬¢è¿æ¥åˆ° {settings.APP_NAME} v{settings.APP_VERSION}. æœåŠ¡è¿è¡Œæ­£å¸¸ã€‚"}


--- æ–‡ä»¶è·¯å¾„: nginx.conf ---

# /nginx.conf
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream doubao_backend {
        # ç”±äºåº”ç”¨å†…éƒ¨å·²å®ç°æœ‰çŠ¶æ€ä¼šè¯ç®¡ç†ï¼Œæ­¤å¤„æ— éœ€ ip_hash
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://doubao_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # æµå¼ä¼ è¾“ä¼˜åŒ–
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
        }
    }
}


--- æ–‡ä»¶è·¯å¾„: requirements.txt ---

# /requirements.txt
fastapi
uvicorn
pydantic-settings
python-dotenv
cloudscraper
cachetools
httpx
loguru
playwright==1.44.0
playwright-stealth==1.0.6


--- æ–‡ä»¶è·¯å¾„: app\core\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\core\config.py ---

# /app/core/config.py
import os
import uuid
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import model_validator
from typing import Optional, List, Dict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "doubao-2api"
    APP_VERSION: str = "1.0.0"
    DESCRIPTION: str = "ä¸€ä¸ªå°† doubao.com è½¬æ¢ä¸ºå…¼å®¹ OpenAI æ ¼å¼ API çš„é«˜æ€§èƒ½ä»£ç†ï¼Œå†…ç½® a_bogus ç­¾åè§£å†³æ–¹æ¡ˆã€‚"

    # --- æ ¸å¿ƒå®‰å…¨ä¸éƒ¨ç½²é…ç½® ---
    API_MASTER_KEY: Optional[str] = "1"
    NGINX_PORT: int = 8088
    
    # --- Doubao å‡­è¯ ---
    DOUBAO_COOKIES: List[str] = []

    # --- æ ¸å¿ƒå˜æ›´: é™æ€è®¾å¤‡æŒ‡çº¹é…ç½® ---
    # ä»æ‚¨æä¾›çš„æœ‰æ•ˆè¯·æ±‚ä¸­æå–çš„é™æ€è®¾å¤‡æŒ‡çº¹ï¼Œè¿™æ¯”åŠ¨æ€å—…æ¢ç¨³å®šå¾—å¤š
    # å¦‚æœæœªæ¥å¤±æ•ˆï¼Œåªéœ€ä»æµè§ˆå™¨æŠ“å–æ–°çš„è¯·æ±‚å¹¶æ›´æ–°æ­¤å¤„çš„å€¼
    DOUBAO_DEVICE_ID: Optional[str] = None
    DOUBAO_FP: Optional[str] = None
    DOUBAO_TEA_UUID: Optional[str] = None
    DOUBAO_WEB_ID: Optional[str] = None

    # --- ä¸Šæ¸¸ API é…ç½® ---
    API_REQUEST_TIMEOUT: int = 180
    
    # --- ä¼šè¯ç®¡ç† ---
    SESSION_CACHE_TTL: int = 3600

    # --- æ¨¡å‹é…ç½® ---
    DEFAULT_MODEL: str = "doubao-pro-chat"
    MODEL_MAPPING: Dict[str, str] = {
        "doubao-pro-chat": "7338286299411103781", # é»˜è®¤æ¨¡å‹ Bot ID
    }

    @model_validator(mode='after')
    def validate_settings(self) -> 'Settings':
        # ä»ç¯å¢ƒå˜é‡ DOUBAO_COOKIE_1, DOUBAO_COOKIE_2, ... åŠ è½½ cookies
        i = 1
        while True:
            cookie_str = os.getenv(f"DOUBAO_COOKIE_{i}")
            if cookie_str:
                self.DOUBAO_COOKIES.append(cookie_str)
                i += 1
            else:
                break
        
        if not self.DOUBAO_COOKIES:
            raise ValueError("å¿…é¡»åœ¨ .env æ–‡ä»¶ä¸­è‡³å°‘é…ç½®ä¸€ä¸ªæœ‰æ•ˆçš„ DOUBAO_COOKIE_1")

        # --- æ ¸å¿ƒå˜æ›´: éªŒè¯è®¾å¤‡æŒ‡çº¹æ˜¯å¦å·²é…ç½® ---
        if not all([self.DOUBAO_DEVICE_ID, self.DOUBAO_FP, self.DOUBAO_TEA_UUID, self.DOUBAO_WEB_ID]):
            raise ValueError("å¿…é¡»åœ¨ .env æ–‡ä»¶ä¸­é…ç½®å®Œæ•´çš„è®¾å¤‡æŒ‡çº¹å‚æ•° (DOUBAO_DEVICE_ID, DOUBAO_FP, DOUBAO_TEA_UUID, DOUBAO_WEB_ID)")
        
        return self

settings = Settings()


--- æ–‡ä»¶è·¯å¾„: app\providers\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\providers\base_provider.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(
        self,
        request_data: Dict[str, Any]
    ) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass


--- æ–‡ä»¶è·¯å¾„: app\providers\doubao_provider.py ---

# /app/providers/doubao_provider.py
import json
import re
import time
import uuid
from typing import Dict, Any, AsyncGenerator, List

import httpx
from fastapi import HTTPException
from fastapi.responses import StreamingResponse, JSONResponse
from loguru import logger

from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.services.credential_manager import CredentialManager
from app.services.playwright_manager import PlaywrightManager
from app.services.session_manager import SessionManager
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK


class DoubaoProvider(BaseProvider):
    def __init__(self):
        self.credential_manager = CredentialManager(settings.DOUBAO_COOKIES)
        self.session_manager = SessionManager()
        self.playwright_manager = PlaywrightManager()
        self.client: httpx.AsyncClient = None

    async def initialize(self):
        self.client = httpx.AsyncClient(timeout=settings.API_REQUEST_TIMEOUT)
        await self.playwright_manager.initialize(self.credential_manager.credentials)

    async def close(self):
        if self.client:
            await self.client.aclose()
        await self.playwright_manager.close()

    def _get_dynamic_cookie(self, base_cookie: str) -> str:
        """
        ç”¨ Playwright æ•è·çš„æœ€æ–° msToken æ›´æ–°åŸºç¡€ Cookie å­—ç¬¦ä¸²ã€‚
        è¿™æ˜¯ç¡®ä¿ç­¾åå’Œè¯·æ±‚å¤´ä¸€è‡´æ€§çš„å…³é”®ã€‚
        """
        latest_ms_token = self.playwright_manager.ms_token
        if not latest_ms_token:
            logger.warning("åŠ¨æ€ Cookie æ›´æ–°å¤±è´¥ï¼šPlaywright ç®¡ç†å™¨ä¸­æ²¡æœ‰å¯ç”¨çš„ msTokenã€‚å°†ä½¿ç”¨åŸå§‹ Cookieã€‚")
            return base_cookie

        if 'msToken=' in base_cookie:
            new_cookie = re.sub(r'msToken=[^;]+', f'msToken={latest_ms_token}', base_cookie)
            logger.info("æˆåŠŸå°†åŠ¨æ€ msToken æ›´æ–°åˆ° Cookie å¤´ä¸­ã€‚")
        else:
            new_cookie = f"{base_cookie.strip(';')}; msToken={latest_ms_token}"
            logger.info("åŸå§‹ Cookie ä¸­æœªæ‰¾åˆ° msTokenï¼Œå·²è¿½åŠ æœ€æ–°çš„ msTokenã€‚")
        
        return new_cookie

    async def chat_completion(self, request_data: Dict[str, Any]):
        """
        æ ¹æ®è¯·æ±‚ä¸­çš„ 'stream' å‚æ•°ï¼Œåˆ†å‘åˆ°æµå¼æˆ–éæµå¼å¤„ç†å‡½æ•°ã€‚
        """
        is_stream = request_data.get("stream", True)

        if is_stream:
            return StreamingResponse(self._stream_generator(request_data), media_type="text/event-stream")
        else:
            return await self._non_stream_completion(request_data)

    async def _non_stream_completion(self, request_data: Dict[str, Any]) -> JSONResponse:
        """
        å¤„ç†éæµå¼èŠå¤©è¡¥å…¨è¯·æ±‚ã€‚
        """
        session_id = request_data.get("user", f"session-{uuid.uuid4().hex}")
        messages = request_data.get("messages", [])
        user_model = request_data.get("model", settings.DEFAULT_MODEL)

        bot_id = settings.MODEL_MAPPING.get(user_model)
        if not bot_id:
            raise HTTPException(status_code=400, detail=f"ä¸æ”¯æŒçš„æ¨¡å‹: {user_model}")

        session_data = self.session_manager.get_session(session_id) or {}
        conversation_id = session_data.get("conversation_id", "0")
        is_new_conversation = conversation_id == "0"

        request_id = f"chatcmpl-{uuid.uuid4()}"
        new_conversation_id = None
        full_content = []
        streamed_any_data = False

        try:
            base_cookie = self.credential_manager.get_credential()
            final_cookie = self._get_dynamic_cookie(base_cookie)
            base_url = "https://www.doubao.com/samantha/chat/completion"
            base_params = {
                "aid": "497858", "device_platform": "web", "language": "zh",
                "pc_version": "2.41.0", "pkg_type": "release_version", "real_aid": "497858",
                "region": "CN", "samantha_web": "1", "sys_region": "CN",
                "use-olympus-account": "1", "version_code": "20800",
            }
            headers = self._prepare_headers(final_cookie)
            payload = self._prepare_payload(messages, bot_id, conversation_id)

            log_headers = headers.copy()
            log_headers["Cookie"] = "[REDACTED FOR SECURITY]"
            logger.info("--- å‡†å¤‡å‘ä¸Šæ¸¸å‘é€çš„å®Œæ•´è¯·æ±‚åŒ… (éæµå¼) ---")
            logger.info(f"è¯·æ±‚æ–¹æ³•: POST")
            logger.info(f"åŸºç¡€URL: {base_url}")
            logger.info(f"è¯·æ±‚å¤´ (Headers):\n{json.dumps(log_headers, indent=2)}")
            logger.info(f"è¯·æ±‚è½½è· (Payload):\n{json.dumps(payload, indent=2, ensure_ascii=False)}")
            logger.info("------------------------------------")

            signed_url = await self.playwright_manager.get_signed_url(base_url, final_cookie, base_params)
            if not signed_url:
                raise Exception("æ— æ³•è·å– a_bogus ç­¾å, Playwright æœåŠ¡å¯èƒ½å¼‚å¸¸ã€‚")

            logger.info(f"ç­¾åæˆåŠŸï¼Œæœ€ç»ˆè¯·æ±‚ URL: {signed_url}")

            async with self.client.stream("POST", signed_url, headers=headers, json=payload) as response:
                new_ms_token = response.headers.get("x-ms-token")
                if new_ms_token:
                    self.playwright_manager.update_ms_token(new_ms_token)
                    logger.success(f"ä»å“åº”å¤´ä¸­æ•è·å¹¶æ›´æ–°äº† msToken: {new_ms_token}")

                if response.status_code != 200:
                    error_content = await response.aread()
                    logger.error(f"ä¸Šæ¸¸æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€ç : {response.status_code}ã€‚")
                    logger.error(f"ä¸Šæ¸¸æœåŠ¡å™¨å“åº”å†…å®¹: {error_content.decode(errors='ignore')}")
                    response.raise_for_status()

                logger.success(f"æˆåŠŸè¿æ¥åˆ°ä¸Šæ¸¸æœåŠ¡å™¨, çŠ¶æ€ç : {response.status_code}. å¼€å§‹æ¥æ”¶å“åº”...")

                async for line in response.aiter_lines():
                    # [è¯Šæ–­æ—¥å¿—] æ‰“å°ä»ä¸Šæ¸¸æ”¶åˆ°çš„æ¯ä¸€è¡ŒåŸå§‹æ•°æ®
                    logger.info(f"ä¸Šæ¸¸åŸå§‹å“åº”è¡Œ: {line}")
                    streamed_any_data = True
                    if not line.startswith("data:"):
                        continue
                    content_str = line[len("data:"):].strip()
                    if not content_str:
                        continue

                    try:
                        data = json.loads(content_str)
                        if data.get("event_type") == 2002 and not new_conversation_id:
                            event_data = json.loads(data.get("event_data", "{}"))
                            new_conversation_id = event_data.get("conversation_id")
                            logger.info(f"æ•è·åˆ°æ–°ä¼šè¯ ID: {new_conversation_id}")

                        if data.get("event_type") == 2001:
                            event_data = json.loads(data.get("event_data", "{}"))
                            message_data = event_data.get("message", {})
                            content_json = json.loads(message_data.get("content", "{}"))
                            delta_content = content_json.get("text", "")
                            if delta_content:
                                full_content.append(delta_content)
                    except (json.JSONDecodeError, KeyError) as e:
                        logger.warning(f"è§£æ SSE æ•°æ®å—æ—¶è·³è¿‡: {e}, å†…å®¹: {content_str}")
                        continue

            if not streamed_any_data:
                logger.error("ä¸Šæ¸¸æœåŠ¡å™¨è¿”å›äº† 200 OKï¼Œä½†æ²¡æœ‰å‘é€ä»»ä½•æ•°æ®æµã€‚è¿™é€šå¸¸æ˜¯ç”±äºåçˆ¬è™«ç­–ç•¥è§¦å‘ã€‚")
                raise Exception("æœåŠ¡å™¨è¿æ¥æˆåŠŸä½†æœªè¿”å›æ•°æ®æµï¼Œè¯·æ±‚å¯èƒ½è¢«ä¸Šæ¸¸æœåŠ¡æ‹¦æˆªã€‚è¯·æ£€æŸ¥Cookieæ˜¯å¦è¿‡æœŸæˆ–IPæ˜¯å¦è¢«é™åˆ¶ã€‚")

            if is_new_conversation and new_conversation_id:
                self.session_manager.update_session(session_id, {"conversation_id": new_conversation_id})
                logger.info(f"ä¸ºç”¨æˆ· '{session_id}' ä¿å­˜äº†æ–°çš„ä¼šè¯ ID: {new_conversation_id}")

            final_text = "".join(full_content)

            # æŒ‰ç…§ç”¨æˆ·è¦æ±‚ï¼Œå°†å®Œæ•´çš„å“åº”å†…å®¹æ‰“å°åˆ°ç»ˆç«¯
            print("\n--- [éæµå¼] å®Œæ•´å“åº”å†…å®¹ ---")
            print(final_text)
            print("---------------------------------\n")

            response_data = {
                "id": request_id,
                "object": "chat.completion",
                "created": int(time.time()),
                "model": user_model,
                "choices": [{
                    "index": 0,
                    "message": {"role": "assistant", "content": final_text},
                    "finish_reason": "stop"
                }],
                "usage": {"prompt_tokens": 0, "completion_tokens": 0, "total_tokens": 0}
            }
            return JSONResponse(content=response_data)

        except Exception as e:
            logger.error(f"å¤„ç†éæµå¼è¯·æ±‚æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}", exc_info=True)
            return JSONResponse(
                status_code=500,
                content={"error": {"message": f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}", "type": "server_error", "code": None}}
            )

    async def _stream_generator(self, request_data: Dict[str, Any]) -> AsyncGenerator[bytes, None]:
        """
        å¤„ç†æµå¼èŠå¤©è¡¥å…¨è¯·æ±‚ã€‚
        """
        session_id = request_data.get("user", f"session-{uuid.uuid4().hex}")
        messages = request_data.get("messages", [])
        user_model = request_data.get("model", settings.DEFAULT_MODEL)

        bot_id = settings.MODEL_MAPPING.get(user_model)
        if not bot_id:
            # This should be handled before calling the generator, but as a safeguard:
            error_chunk = create_chat_completion_chunk(f"chatcmpl-{uuid.uuid4()}", user_model, f"ä¸æ”¯æŒçš„æ¨¡å‹: {user_model}", "stop")
            yield create_sse_data(error_chunk)
            yield DONE_CHUNK
            return

        session_data = self.session_manager.get_session(session_id) or {}
        conversation_id = session_data.get("conversation_id", "0")
        is_new_conversation = conversation_id == "0"

        request_id = f"chatcmpl-{uuid.uuid4()}"
        new_conversation_id = None
        streamed_any_data = False

        try:
            base_cookie = self.credential_manager.get_credential()
            final_cookie = self._get_dynamic_cookie(base_cookie)
            base_url = "https://www.doubao.com/samantha/chat/completion"
            base_params = {
                "aid": "497858", "device_platform": "web", "language": "zh",
                "pc_version": "2.41.0", "pkg_type": "release_version", "real_aid": "497858",
                "region": "CN", "samantha_web": "1", "sys_region": "CN",
                "use-olympus-account": "1", "version_code": "20800",
            }
            headers = self._prepare_headers(final_cookie)
            payload = self._prepare_payload(messages, bot_id, conversation_id)

            log_headers = headers.copy()
            log_headers["Cookie"] = "[REDACTED FOR SECURITY]"
            logger.info("--- å‡†å¤‡å‘ä¸Šæ¸¸å‘é€çš„å®Œæ•´è¯·æ±‚åŒ… (æµå¼) ---")
            logger.info(f"è¯·æ±‚æ–¹æ³•: POST")
            logger.info(f"åŸºç¡€URL: {base_url}")
            logger.info(f"è¯·æ±‚å¤´ (Headers):\n{json.dumps(log_headers, indent=2)}")
            logger.info(f"è¯·æ±‚è½½è· (Payload):\n{json.dumps(payload, indent=2, ensure_ascii=False)}")
            logger.info("------------------------------------")

            signed_url = await self.playwright_manager.get_signed_url(base_url, final_cookie, base_params)
            if not signed_url:
                raise Exception("æ— æ³•è·å– a_bogus ç­¾å, Playwright æœåŠ¡å¯èƒ½å¼‚å¸¸ã€‚")

            logger.info(f"ç­¾åæˆåŠŸï¼Œæœ€ç»ˆè¯·æ±‚ URL: {signed_url}")

            # æŒ‰ç…§ç”¨æˆ·è¦æ±‚ï¼Œåœ¨æµå¼è¾“å‡ºå‰æ‰“å°ä¸€ä¸ªæ ‡è¯†
            print("\n--- [æµå¼] å“åº”å†…å®¹ ---")

            async with self.client.stream("POST", signed_url, headers=headers, json=payload) as response:
                new_ms_token = response.headers.get("x-ms-token")
                if new_ms_token:
                    self.playwright_manager.update_ms_token(new_ms_token)
                    logger.success(f"ä»å“åº”å¤´ä¸­æ•è·å¹¶æ›´æ–°äº† msToken: {new_ms_token}")

                if response.status_code != 200:
                    error_content = await response.aread()
                    logger.error(f"ä¸Šæ¸¸æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€ç : {response.status_code}ã€‚")
                    logger.error(f"ä¸Šæ¸¸æœåŠ¡å™¨å“åº”å†…å®¹: {error_content.decode(errors='ignore')}")
                    response.raise_for_status()

                logger.success(f"æˆåŠŸè¿æ¥åˆ°ä¸Šæ¸¸æœåŠ¡å™¨, çŠ¶æ€ç : {response.status_code}. å¼€å§‹æ¥æ”¶å“åº”...")

                async for line in response.aiter_lines():
                    # [è¯Šæ–­æ—¥å¿—] æ‰“å°ä»ä¸Šæ¸¸æ”¶åˆ°çš„æ¯ä¸€è¡ŒåŸå§‹æ•°æ®
                    logger.info(f"ä¸Šæ¸¸åŸå§‹å“åº”è¡Œ: {line}")
                    streamed_any_data = True
                    if not line.startswith("data:"):
                        continue
                    content_str = line[len("data:"):].strip()
                    if not content_str:
                        continue

                    try:
                        data = json.loads(content_str)
                        if data.get("event_type") == 2002 and not new_conversation_id:
                            event_data = json.loads(data.get("event_data", "{}"))
                            new_conversation_id = event_data.get("conversation_id")
                            logger.info(f"æ•è·åˆ°æ–°ä¼šè¯ ID: {new_conversation_id}")

                        if data.get("event_type") == 2001:
                            event_data = json.loads(data.get("event_data", "{}"))
                            message_data = event_data.get("message", {})
                            content_json = json.loads(message_data.get("content", "{}"))
                            delta_content = content_json.get("text", "")
                            if delta_content:
                                # æŒ‰ç…§ç”¨æˆ·è¦æ±‚ï¼Œå°†æµå¼æ•°æ®å—ç›´æ¥æ‰“å°åˆ°ç»ˆç«¯
                                print(delta_content, end="", flush=True)
                                chunk = create_chat_completion_chunk(request_id, user_model, delta_content)
                                yield create_sse_data(chunk)
                    except (json.JSONDecodeError, KeyError) as e:
                        logger.warning(f"è§£æ SSE æ•°æ®å—æ—¶è·³è¿‡: {e}, å†…å®¹: {content_str}")
                        continue
            
            # åœ¨æµå¼è¾“å‡ºç»“æŸåæ‰“å°æ¢è¡Œç¬¦å’Œç»“æŸæ ‡è¯†
            if streamed_any_data:
                print("\n--------------------------\n")

            if not streamed_any_data:
                logger.error("ä¸Šæ¸¸æœåŠ¡å™¨è¿”å›äº† 200 OKï¼Œä½†æ²¡æœ‰å‘é€ä»»ä½•æ•°æ®æµã€‚è¿™é€šå¸¸æ˜¯ç”±äºåçˆ¬è™«ç­–ç•¥è§¦å‘ã€‚")
                error_message = "æœåŠ¡å™¨è¿æ¥æˆåŠŸä½†æœªè¿”å›æ•°æ®æµï¼Œè¯·æ±‚å¯èƒ½è¢«ä¸Šæ¸¸æœåŠ¡æ‹¦æˆªã€‚è¯·æ£€æŸ¥Cookieæ˜¯å¦è¿‡æœŸæˆ–IPæ˜¯å¦è¢«é™åˆ¶ã€‚"
                error_chunk = create_chat_completion_chunk(request_id, user_model, error_message, "stop")
                yield create_sse_data(error_chunk)
                yield DONE_CHUNK
                return

            if is_new_conversation and new_conversation_id:
                self.session_manager.update_session(session_id, {"conversation_id": new_conversation_id})
                logger.info(f"ä¸ºç”¨æˆ· '{session_id}' ä¿å­˜äº†æ–°çš„ä¼šè¯ ID: {new_conversation_id}")

            final_chunk = create_chat_completion_chunk(request_id, user_model, "", "stop")
            yield create_sse_data(final_chunk)
            yield DONE_CHUNK

        except Exception as e:
            logger.error(f"å¤„ç†æµæ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}", exc_info=True)
            # åœ¨æµå¼è¾“å‡ºç»“æŸåæ‰“å°æ¢è¡Œç¬¦å’Œç»“æŸæ ‡è¯†
            print("\n--- [æµå¼] å‘ç”Ÿé”™è¯¯ ---\n")
            error_chunk = create_chat_completion_chunk(request_id, user_model, f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}", "stop")
            yield create_sse_data(error_chunk)
            yield DONE_CHUNK

    def _prepare_headers(self, cookie: str) -> Dict[str, str]:
        return {
            "Accept": "*/*", "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Content-Type": "application/json", "Cookie": cookie,
            "Origin": "https://www.doubao.com", "Referer": "https://www.doubao.com/chat/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
            "agw-js-conv": "str, str",
            "sec-ch-ua": '"Google Chrome";v="141", "Not?A_Brand";v="8", "Chromium";v="141"',
            "sec-ch-ua-mobile": "?0", "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "empty", "sec-fetch-mode": "cors", "sec-fetch-site": "same-origin",
        }

    def _prepare_payload(self, messages: List[Dict[str, Any]], bot_id: str, conversation_id: str) -> Dict[str, Any]:
        last_user_message = next((m for m in reversed(messages) if m.get("role") == "user"), None)
        if not last_user_message:
            raise HTTPException(status_code=400, detail="æœªæ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯ã€‚")

        payload = {
            "messages": [{"content": json.dumps({"text": last_user_message["content"]}), "content_type": 2001, "attachments": [], "references": []}],
            "completion_option": {
                "is_regen": False, "with_suggest": True, "need_create_conversation": conversation_id == "0",
                "launch_stage": 1, "is_replace": False, "is_delete": False, "message_from": 0,
                "action_bar_skill_id": 0, "use_deep_think": False, "use_auto_cot": True,
                "resend_for_regen": False, "enable_commerce_credit": False, "event_id": "0"
            },
            "evaluate_option": {"web_ab_params": ""},
            "conversation_id": conversation_id,
            "local_conversation_id": f"local_{uuid.uuid4().hex}",
            "local_message_id": str(uuid.uuid4())
        }

        if conversation_id != "0":
            payload["bot_id"] = bot_id
        
        return payload

    async def get_models(self) -> JSONResponse:
        return JSONResponse(content={
            "object": "list",
            "data": [{"id": name, "object": "model", "created": int(time.time()), "owned_by": "lzA6"} for name in settings.MODEL_MAPPING.keys()]
        })


--- æ–‡ä»¶è·¯å¾„: app\services\credential_manager.py ---

# /app/services/credential_manager.py
import threading
from typing import List
from loguru import logger

class CredentialManager:
    def __init__(self, credentials: List[str]):
        if not credentials:
            raise ValueError("å‡­è¯åˆ—è¡¨ä¸èƒ½ä¸ºç©ºã€‚")
        self.credentials = credentials
        self.index = 0
        self.lock = threading.Lock()
        logger.info(f"å‡­è¯ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼Œå…±åŠ è½½ {len(self.credentials)} ä¸ªå‡­è¯ã€‚")

    def get_credential(self) -> str:
        with self.lock:
            credential = self.credentials[self.index]
            self.index = (self.index + 1) % len(self.credentials)
            logger.debug(f"è½®è¯¢åˆ°å‡­è¯ç´¢å¼•: {self.index}")
            return credential


--- æ–‡ä»¶è·¯å¾„: app\services\playwright_manager.py ---

# /app/services/playwright_manager.py
import asyncio
import json
import uuid
from typing import Optional, Dict, List
from urllib.parse import urlencode, urlparse

from playwright_stealth import stealth_async
from playwright.async_api import async_playwright, Browser, Page, ConsoleMessage, TimeoutError, Route, Request
from loguru import logger

from app.core.config import settings # å¯¼å…¥ settings

def handle_console_message(msg: ConsoleMessage):
    """å°†æµè§ˆå™¨æ§åˆ¶å°æ—¥å¿—è½¬å‘åˆ° Loguruï¼Œå¹¶è¿‡æ»¤å·²çŸ¥å™ªéŸ³"""
    log_level = msg.type.upper()
    text = msg.text
    # è¿‡æ»¤æ‰å¸¸è§çš„ã€æ— å®³çš„æµè§ˆå™¨å™ªéŸ³
    if "Failed to load resource" in text or "net::ERR_FAILED" in text:
        return
    if "WebSocket connection" in text:
        return
    if "Content Security Policy" in text:
        return
    if "Scripts may close only the windows that were opened by them" in text:
        return
    if "Ignoring too frequent calls to print()" in text:
        return

    log_message = f"[Browser Console] {text}"
    if log_level == "ERROR":
        logger.error(log_message)
    elif log_level == "WARNING":
        logger.warning(log_message)
    else:
        pass

class PlaywrightManager:
    _instance = None
    _lock = asyncio.Lock()

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(PlaywrightManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    async def initialize(self, cookies: List[str]):
        if self._initialized:
            return
        async with self._lock:
            if self._initialized:
                return
            logger.info("æ­£åœ¨åˆå§‹åŒ– Playwright ç®¡ç†å™¨ (ç­¾åæœåŠ¡æ¨¡å¼)...")
            self.playwright = await async_playwright().start()
            self.browser = await self.playwright.chromium.launch(
                headless=True,
                args=["--no-sandbox", "--disable-setuid-sandbox"]
            )
            self.page = await self.browser.new_page()

            await stealth_async(self.page)
            self.page.on("console", handle_console_message)
            await self.page.add_init_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

            self.static_device_fingerprint = {
                'device_id': settings.DOUBAO_DEVICE_ID,
                'fp': settings.DOUBAO_FP,
                'web_id': settings.DOUBAO_WEB_ID,
                'tea_uuid': settings.DOUBAO_TEA_UUID
            }
            logger.success(f"å·²ä»é…ç½®ä¸­åŠ è½½é™æ€è®¾å¤‡æŒ‡çº¹: {self.static_device_fingerprint}")
            
            self.ms_token = None

            async def _handle_response(response):
                try:
                    if 'x-ms-token' in response.headers:
                        token = response.headers['x-ms-token']
                        if token != self.ms_token:
                            self.ms_token = token
                            logger.success(f"é€šè¿‡å“åº”å¤´æ•è·åˆ°æ–°çš„ msToken: {self.ms_token}")
                except Exception as e:
                    logger.warning(f"å¤„ç†å“åº”æ—¶å‡ºé”™: {e} (URL: {response.url})")

            self.page.on("response", _handle_response)

            if not cookies:
                raise ValueError("Playwright åˆå§‹åŒ–éœ€è¦è‡³å°‘ä¸€ä¸ªæœ‰æ•ˆçš„ Cookieã€‚")
            
            logger.info("æ­£åœ¨ä¸ºåˆå§‹é¡µé¢åŠ è½½è®¾ç½® Cookie...")
            initial_cookie_str = cookies[0]
            try:
                cookie_list = [
                    {"name": c.split('=')[0].strip(), "value": c.split('=', 1)[1].strip(), "domain": ".doubao.com", "path": "/"}
                    for c in initial_cookie_str.split(';') if '=' in c
                ]
                await self.page.context.add_cookies(cookie_list)
                logger.success("åˆå§‹ Cookie è®¾ç½®å®Œæˆã€‚")
            except IndexError as e:
                logger.error(f"è§£æ Cookie æ—¶å‡ºé”™: '{initial_cookie_str}'. è¯·ç¡®ä¿ Cookie æ ¼å¼æ­£ç¡®ã€‚é”™è¯¯: {e}")
                raise ValueError("Cookie æ ¼å¼æ— æ•ˆï¼Œæ— æ³•è¿›è¡Œåˆå§‹åŒ–ã€‚") from e

            try:
                logger.info("æ­£åœ¨å¯¼èˆªåˆ°è±†åŒ…å®˜ç½‘ä»¥åŠ è½½ç­¾åè„šæœ¬ (è¶…æ—¶æ—¶é—´: 60ç§’)...")
                await self.page.goto(
                    "https://www.doubao.com/chat/",
                    wait_until="load",
                    timeout=60000
                )
                logger.info("é¡µé¢å¯¼èˆªå®Œæˆ (load äº‹ä»¶è§¦å‘)ã€‚")
            except TimeoutError as e:
                logger.error(f"å¯¼èˆªåˆ°è±†åŒ…å®˜ç½‘è¶…æ—¶: {e}")
                raise RuntimeError("æ— æ³•è®¿é—®è±†åŒ…å®˜ç½‘ï¼Œåˆå§‹åŒ–å¤±è´¥ã€‚") from e

            try:
                logger.info("æ­£åœ¨ç­‰å¾…å…³é”®ç­¾åå‡½æ•° (window.byted_acrawler.frontierSign) åŠ è½½ (è¶…æ—¶æ—¶é—´: 30ç§’)...")
                await self.page.wait_for_function(
                    "() => typeof window.byted_acrawler?.frontierSign === 'function'",
                    timeout=30000
                )
                logger.success("å…³é”®ç­¾åå‡½æ•°å·²åœ¨å¯åŠ¨æ—¶æˆåŠŸåŠ è½½ï¼")
            except TimeoutError:
                logger.error("ç­‰å¾…ç­¾åå‡½æ•°è¶…æ—¶ï¼è¿™å¾ˆå¯èƒ½æ˜¯å› ä¸º Cookie æ— æ•ˆæˆ–å·²è¿‡æœŸã€‚")
                raise RuntimeError("æ— æ³•åŠ è½½è±†åŒ…ç­¾åå‡½æ•°ï¼Œè¯·æ£€æŸ¥å¹¶æ›´æ–° Cookieã€‚")
            
            if not self.ms_token:
                logger.info("ç­‰å¾… msToken å‡ºç°ï¼Œæœ€é•¿ç­‰å¾… 10 ç§’...")
                await asyncio.sleep(10)
                if not self.ms_token:
                    logger.warning("åœ¨é¢å¤–ç­‰å¾…åï¼Œä¾ç„¶æœªèƒ½æ•è·åˆ°åˆå§‹ msTokenã€‚åç»­è¯·æ±‚å°†ä¾èµ–å“åº”å¤´æ›´æ–°ã€‚")

            logger.success("Playwright ç®¡ç†å™¨ (ç­¾åæœåŠ¡æ¨¡å¼) åˆå§‹åŒ–å®Œæˆã€‚")
            self._initialized = True

    def update_ms_token(self, token: str):
        self.ms_token = token

    async def get_signed_url(self, base_url: str, cookie: str, base_params: Dict[str, str]) -> Optional[str]:
        async with self._lock:
            if not self._initialized:
                raise RuntimeError("PlaywrightManager æœªåˆå§‹åŒ–ã€‚")
            
            try:
                logger.info("æ­£åœ¨ä½¿ç”¨ Playwright ç”Ÿæˆ a_bogus ç­¾å...")
                
                final_params = base_params.copy()
                final_params.update(self.static_device_fingerprint)
                
                final_params['web_tab_id'] = str(uuid.uuid4())
                if self.ms_token:
                    final_params['msToken'] = self.ms_token
                else:
                    logger.error("msToken æœªè¢«åˆå§‹åŒ–ï¼Œæ— æ³•æ„å»ºæœ‰æ•ˆè¯·æ±‚ï¼")
                    return None

                # --- æ ¸å¿ƒä¿®å¤: å¯¹å‚æ•°è¿›è¡Œå­—æ¯æ’åºï¼Œä»¥ç”Ÿæˆæ­£ç¡®çš„ç­¾å ---
                sorted_params = dict(sorted(final_params.items()))
                final_query_string = urlencode(sorted_params)
                url_with_params = f"{base_url}?{final_query_string}"

                logger.info(f"æ­£åœ¨ä½¿ç”¨é™æ€æŒ‡çº¹å’Œæ’åºåçš„å‚æ•°è°ƒç”¨ window.byted_acrawler.frontierSign: \"{final_query_string}\"")
                signature_obj = await self.page.evaluate(f'window.byted_acrawler.frontierSign("{final_query_string}")')
                
                if isinstance(signature_obj, dict) and ('a_bogus' in signature_obj or 'X-Bogus' in signature_obj):
                    bogus_value = signature_obj.get('a_bogus') or signature_obj.get('X-Bogus')
                    logger.success(f"æˆåŠŸè§£æç­¾åå¯¹è±¡ï¼Œè·å–åˆ° a_bogus: {bogus_value}")
                    
                    signed_url = f"{url_with_params}&a_bogus={bogus_value}"
                    return signed_url
                else:
                    logger.error(f"è°ƒç”¨ç­¾åå‡½æ•°å¤±è´¥ï¼Œè¿”å›å€¼ä¸æ˜¯é¢„æœŸçš„å­—å…¸æ ¼å¼æˆ–ç¼ºå°‘ a_bogus: {signature_obj}")
                    return None

            except Exception as e:
                logger.error(f"Playwright ç­¾åæ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}", exc_info=True)
                return None

    async def close(self):
        if self._initialized:
            async with self._lock:
                if self.browser:
                    await self.browser.close()
                if self.playwright:
                    await self.playwright.stop()
                self._initialized = False
                logger.info("Playwright ç®¡ç†å™¨å·²å…³é—­ã€‚")


--- æ–‡ä»¶è·¯å¾„: app\services\session_manager.py ---

# /app/services/session_manager.py
import threading
from cachetools import TTLCache
from typing import Dict, Any, Optional
from app.core.config import settings
from loguru import logger

class SessionManager:
    def __init__(self):
        self.cache = TTLCache(maxsize=1024, ttl=settings.SESSION_CACHE_TTL)
        self.lock = threading.Lock()
        logger.info(f"ä¼šè¯ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼Œç¼“å­˜ TTL: {settings.SESSION_CACHE_TTL} ç§’ã€‚")

    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        with self.lock:
            return self.cache.get(session_id)

    def update_session(self, session_id: str, data: Dict[str, Any]):
        with self.lock:
            self.cache[session_id] = data
            logger.debug(f"ä¼šè¯ {session_id} å·²æ›´æ–°ã€‚")


--- æ–‡ä»¶è·¯å¾„: app\utils\sse_utils.py ---

# /app/utils/sse_utils.py
import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    return f"data: {json.dumps(data)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content},
                "finish_reason": finish_reason
            }
        ]
    }



